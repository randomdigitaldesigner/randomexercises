$date
	Wed Oct  7 22:08:55 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module top $end
$var wire 15 ! \$1 [14:0] $end
$var wire 12 " input_0 [11:0] $end
$var wire 12 # input_1 [11:0] $end
$var wire 12 $ input_2 [11:0] $end
$var wire 12 % input_3 [11:0] $end
$var wire 12 & input_4 [11:0] $end
$var wire 12 ' input_5 [11:0] $end
$var wire 12 ( input_6 [11:0] $end
$var wire 12 ) input_7 [11:0] $end
$var wire 8 * output [7:0] $end
$var wire 8 + round_conv_output [7:0] $end
$var wire 12 , round_conv_input [11:0] $end
$var wire 13 - \$8 [12:0] $end
$var wire 14 . \$6 [13:0] $end
$var wire 13 / \$4 [12:0] $end
$var wire 13 0 \$2 [12:0] $end
$var wire 15 1 \$14 [14:0] $end
$var wire 14 2 \$12 [13:0] $end
$var wire 13 3 \$10 [12:0] $end
$scope module round_conv $end
$var wire 1 4 \$3 $end
$var wire 9 5 \$5 [8:0] $end
$var wire 8 6 \$9 [7:0] $end
$var wire 1 7 in_the_middle $end
$var wire 12 8 input [11:0] $end
$var wire 12 9 nearest_input [11:0] $end
$var wire 8 : truncated [7:0] $end
$var wire 8 ; nearest_output [7:0] $end
$var wire 8 < \$8 [7:0] $end
$var wire 9 = \$6 [8:0] $end
$var wire 1 > \$11 $end
$var wire 1 ? \$1 $end
$var reg 8 @ output [7:0] $end
$scope module nearest $end
$var wire 13 A \$1 [12:0] $end
$var wire 12 B input [11:0] $end
$var wire 12 C offseteada [11:0] $end
$var wire 8 D output [7:0] $end
$var wire 1 E \$5 $end
$var wire 12 F \$4 [11:0] $end
$var wire 13 G \$2 [12:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10100101110 G
b10100101110 F
1E
b1010010 D
b10100101110 C
b10100100110 B
b10100101110 A
b1010010 @
0?
1>
b1010011 =
b1010011 <
b1010010 ;
b1010010 :
b10100100110 9
b10100100110 8
07
b1111110 6
b1010011 5
04
b1111111000101 3
b11100100110 2
b10100100110 1
b10001001010 0
b1100110110110 /
b11111000000000 .
b11101100001 -
b10100100110 ,
b1010010 +
b1010010 *
b1110110111 )
b110000001110 (
b1110001101 '
b1111010100 &
b100000111 %
b100010101111 $
b1001001101 #
b111111101 "
b10100100110 !
$end
#1001
